<!doctype html>
<script src=/boot.js></script>
<link rel=stylesheet href=/tron.css>
<title>Core Schemas</title>

<div id=view>
<main markdown>
<header>
  <h1>Core Schemas</h1>
  <h2>extensible GraphQL schemas for powering data cores</h2>

  <table class=spec-md>
    <tr>
      <td>status</td>
      <td id=spec-md-status>Draft</dd>
    </tr>
    <tr>
      <td>version</td>
      <td id=spec-md-version>0.1</dd>
    </tr>
    <tr>
      <td>authors</td>
      <td id=spec-md-authors>
        <ul class=spec-authors-list>
          <li><a rel=author href=mailto:ashi@apollographql.com>Ashi Krishnan</a>
        </ul>
      </td>
    </tr>
  </table>
</header>

## Problem

[GraphQL](https://spec.graphql.org/) provides directives as a means of attaching user-defined metadata to a GraphQL document. Directives are highly flexible, and can be used to suggest behavior and define features of a graph which are not otherwise evident in the schema.

Alas, *GraphQL does not provide a mechanism to globally identify or version directives*. Given a particular directive—e.g. `@external`—processors are expected to know how to interpret the directive based only on its name, definition within the document, and additional configuration from outside the document. This means that programs interpreting these directives have two options:

  1. rely on a hardcoded interpretation for directives with certain signatures, or
  2. accept additional configuration about how to interpret directives in the schema.

The first solution is fragile, particularly as GraphQL has no built-in namespacing mechanisms, so the possibility of name collisions always looms.

The second is unfortunate: GraphQL schemas are generally intended to be self-describing, and requiring additional configuration subtly undermines this guarantee: given just a schema, programs do not necessarily know how to interpret it, and certainly not how to serve it. It also creates the possibility for the schema and configuration to fall out of sync, leading to issues which can manifest late in a deployment pipeline.

## Core Schemas

Introducing **core schemas**.

<div class=hbox>
  <a class=core>
    <div class=ring></div>
    <div class=nucleus>core schema</div>
  </a>
</div>

A basic core schema:

<view-of src=basic.graphql title='Basic core schema'></view-of>

**Core schemas** provide a clear and concise mechanism for schema documents to specify the intended meaning of the directives which they contain. Additionally, they provide:
  - [**Flexible namespacing rules.**](#prefixing) It is always possible to represent any GraphQL schema within a core schema document. Additionally, documents can [choose the names](#as) they use for the directives they reference, guaranteeing that namespace collisions can always be resolved.
  - [**Directive versioning.**](#versioning) Directive specifications follow [semver-like semantic versioning principles](#versioning), which helps schema processors determine if they are able to correctly interpret a document's metadata.
  - [**Standard rules for extensibility**](#extensibility) of directives and their associated input types. These rules allow specs to annotate each others' metadata, effectively providing "directives on directives," which are otherwise impossible within the GraphQL schema language

**Core schemas are not a new language.** All core schema documents are valid GraphQL schema documents. However, this specification introduces new requirements, so not all valid GraphQL schemas are valid core schemas.

The broad intention behind core schemas is to provide a *single document* which provides all the necessary configuration of a *data core*—some program which serves the schema to GraphQL clients, primarily by following directives in order to determine how to resolve queries made against that schema.

### Parts of a Core Schema

When talking about a core schema, we can broadly break it into two pieces:
- an **API** consisting of exported schema elements (objects, interfaces, enums, directives, etc.) which **should** be served to clients, and
- **machinery** consisting of directives and associated input types (such as enums and input objects). Machinery **must not** be served to clients.

## Roles

```mermaid
#::[Actors who may be interested in the core schemas]
graph TB
  author("👩🏽‍💻 🤖  &nbsp;Author")-->schema(["☉ Core Schema"])
  schema-->proc1("🤖 &nbsp;Processor")
  proc1-->output1(["☉ Core Schema[0]"])
  output1-->proc2("🤖 &nbsp;Processor")
  proc2-->output2(["☉ Core Schema[1]"])
  output2-->etc("...")
  etc-->final(["☉ Core Schema [final]"])
  final-->core("🤖 Data Core")
  schema-->reader("👩🏽‍💻  Reader")
  output1-->reader
  output2-->reader
  final-->reader
```

- **Authors (either human or machine)** write an initial core schema as specified in this document, including versioned `@core` requests for all directives they use
- **Machine processors** can process core schemas and output new core schemas. The versioning of directives and associated schema elements provided by the `@core` allows processors to operate on directives they understand and pass through directives they do not.
- **Human readers** can examine the core schema at various stages of processing. At any stage, they can examine the `@core` directives and follow URLs to the specification, receiving an explanation of the requirements of the specification and what new directives, types, and other schema objects are available within the document.
- **Data cores** can then pick up the processed core schema and provide some data-layer service with it. Typically this means serving the export schema as a GraphQL endpoint, using metadata defined by machinery to inform how it processes operations it receives. However, data cores may perform other tasks described in the core schema, such as routing to backend services, caching commonly-accessed fields and queries, and so on. The term "data core" is intended to capture this multiplicity of possible activities.

## The Basics

Core schemas:
  1. **must** be valid GraphQL schema documents,
  2. **must** contain exactly one `SchemaDefinition`, and
  3. **should** use the `@core` directive on their schema definition to declare any directives they reference by
  [`@core(feature:)`](#feature) a [well-formed specification URL](#feature-urls)

The first `@core` directive on the schema **must** reference the core spec itself, i.e. this document.

<view-of src=basic.graphql title='Basic core schema using @core and @example'></view-of>

### Unspecified directives are passed through

Existing schemas likely contain definitions for directives which are not versioned, have no specification document, and are intended mainly to be passed through. This is the default behavior for core schema processors:

```graphql
#::[Unspecified directives are passed through]
schema
  @core(feature: "https://lib.apollo.dev/core/v0.1")
{
  query: Query
}

type SomeType {
  field: Int @another
}

# `@another` is unspecified. Core processors will not extract metadata from
# it, but its definition and all usages within the schema will be exposed
# in the export schema.
directive @another on FIELD
```

### Renaming `@core` itself

It is possible to rename the `@core` directive itself with the same `as` mechanism used for all specs:

```graphql
#::[Renaming `@core`]
schema
  @coreSchema(feature: "https://lib.apollo.dev/core/v0.1", as: "coreSchema")
  @coreSchema(feature: "https://example.com/example/v1.0")
{
  query: Query
}

type SomeType {
  field: Int @example
}

directive @example on FIELD
```

## `@core`

```graphql
#::[The `@core` directive]
directive @core(feature: String!, as: String, export: Boolean)
  repeatable on SCHEMA
```

Declare a core feature present in this schema.

Documents **must** include a definition for the `@core` directive. The provided definition must be *compatible* with the definition above, but may:
- **Omit optional arguments** if they are never used in the document,
- **Omit locations** where the directive never occurs,
- **Introduce new directive locations**, the behavior of which is unspecified here.
- **Introduce new arguments.** New arguments **must** be prefixed, e.g. `example__extensionArgument: Bool`. The prefix **must** be the name of a feature referenced with this or another `@core` directive within the document.

### `feature: `[core__FeatureUrl](#core__featureurl)

A [feature URL](#core__FeatureUrl) specifying the directive and associated schema elements. When viewed, the URL **should** provide the content of the appropriate version of the specification in some human-readable form. In short, a human reader should be able to click the link and go to the docs for the version in use. There are specific requirements on the format of the URL, but it is not required that the *content* be machine-readable in any particular way.

<figure>
  <figcaption>
    <a name=anatomy-of-a-feature-url href=#anatomy-of-a-feature-url class=a-header>Basic anatomy of a feature URL</a>
  </figcaption>  
  <code class=anatomy>
    <span class=pink style='--depth: 2'>http://spec.example.com/a/b/c/<span>exampleSpec<aside>name</aside></span><aside>
      identity
    </aside></span>/<span style='--depth: 2' class=green>v1.0<aside>version</aside></span>
  </code>
</figure>

Feature URLs contain information about the spec's [prefix](#prefixing) and [version](#versioning), and should be generated and processed in accordance with the [requirements on the structure of feature URLs](#feature-urls).

### `as: String`

Change the [names](#prefixing) of directives and schema elements from this specification. The specified string **must** be a valid GraphQL identifier and **must** not contain the namespace separator (two underscores, `__`).

When a `as` is provided, processors **must** configure the resulting implementation to replace the default name prefix on the names of all [prefixed schema elements](#elements-which-should-be-prefixed) with the specified name.

```graphql
#::[Using the `@core` directive with a custom name]
schema
  @core(feature: "https://spec.example.com/core/v1.0")
  @core(feature: "https://spec.example.com/example/v1.0", as: "eg")
{
  query: Query
}

type User {
  # Specifying `as: "eg"` transforms @example into @eg
  name: String @eg(data: ITEM)
}

# Additional specified schema elements must have their prefixes set
# to the new name.
#
# This data enum was specified as `example__Data`, but will be renamed
# as `eg__Data`:
enum eg__Data {
  ITEM
}

# Name transformation must also be applied to definitions pulled in from
# specifications.
directive @eg(data: eg__Data) on FIELD

# (...other definitions omitted...)
```

## `@core__export`

Control the export of individual schema elements.

```graphql
#::[The `@core__export` directive]
directive @core__export(isExport: Boolean = true)
  repeatable on
  | SCALAR
  | OBJECT
  | FIELD_DEFINITION
  | ARGUMENT_DEFINITION
  | INTERFACE
  | UNION
  | ENUM
  | ENUM_VALUE
  | INPUT_OBJECT
  | INPUT_FIELD_DEFINITION
```

`@core__export` can occur at any type system location. Elements with `@core__export` will always be included in the export schema. Elements with `@core__export(isExport: false)` will always be excluded from the export schema.

## Requiring core schemas within a spec

Specifications **may** include the following language to instruct schema authors to use core schema mechanisms to reference them:

> SPEC_NAME schema documents **must** be valid [core schemas](/core/drafts/pre-0), and must
> reference SPEC_NAME and the specification URL `SPEC_URL`:
>
> ```graphql
> schema
>   @core(feature: "https://lib.apollo.dev/core/v0.1")
>   @core(feature: SPEC_URL)
> {
>   query: Query
> }
> ```

`SPEC_NAME` and `SPEC_URL` should be replaced with the names and URLs for the specification. For example:

> Example Spec schema documents **must** have a `schema` declaration with a [`@core` directive](/core/drafts/pre-0)
> and the specification URL `https://specs.example.com/example/v1.0`:
>
> ```graphql
> schema
>   @core(feature: "https://lib.apollo.dev/core/v0.1")
>   @core(feature: "https://specs.example.com/example/v1.0")
> {
>   query: Query
> }
> ```

## `core__FeatureUrl`

Feature URLs serve two main purposes:
  - Directing human readers to documentation about the feature
  - Providing tools with information about the specs in use, along with enough information to select and invoke an implementation
  
Feature URLs **should** be [RFC 3986 URLs](https://tools.ietf.org/html/rfc3986). When viewed, the URL **should** provide the content of the selected version of the specification in some human-readable form; a human reader should be able to click the link and go to the correct version of the docs.

Although they are not prohibited from doing so, it's assumed that processors will not load the content of feature URLs. Published specifications are not required to be machine-readable, and [this spec](.) places no requirements on the structure or syntax of the content to be found there.

There are, however, requirements on the structure of the URL itself:

<figure>
  <figcaption>
    <a name=basic-anatomy-of-a-feature-url href=#basic-anatomy-of-a-feature-url class=a-header>Basic anatomy of a feature URL</a>
  </figcaption>  
  <code class=anatomy>
    <span class=pink style='--depth: 2'>https://spec.example.com/a/b/c/<span>exampleFeature<aside>name</aside></span><aside>
      identity
    </aside></span>/<span style='--depth: 2' class=green>v1.0<aside>version</aside></span>
  </code>
</figure>

The final two segments of the URL's [path](https://tools.ietf.org/html/rfc3986#section-3.3) **should** contain the feature's [default prefix](#prefix) and a [version tag](#versioning). The content of the URL up to and including the prefix—but excluding the version tag and trailing `/`—is the feature's *identity*. For the above example,
<dl>
  <dt markdown>`identity: "https://spec.example.com/a/b/c/exampleFeature"`</dt>
  <dd>A global identifier for the feature. Processors can treat this as an opaque string identifying the feature (but not the version of the feature) for purposes of selecting an appropriate implementation.</dd>
  <dt markdown>`name: "exampleFeature"`</dt>
  <dd markdown>The feature's name, for purposes of [prefixing](#prefixing) schema elements it defines or extends.</dd>
  <dt markdown>`version: "v1.0"`</dt>
  <dd markdown>The tag for the [version](#versioning) of the feature used to author the document. Processors **must** select an implementation of the feature which can [satisfy](#satisfaction) the specified version.</dd>
</dl>

The version tag **must** satisfy the [BNF grammar for `‹version tag›`](#backus-naur-form-for-versions-and-version-tags).

### Ignore meaningless URL components

When extracting the URL's `prefix` and `version`, processors **must** ignore any url components which are not assigned a meaning. This spec assigns meaning to the final two components of the [path](https://tools.ietf.org/html/rfc3986#section-3.3). Other URL components—particularly query strings and fragments, if present—**must** be ignored for the purposes of extracting the `prefix` and `version`.

<figure>
  <figcaption>
    <a name=feature-url-ignore-meaningless href=#feature-url-ignore-meaningless class=a-header>Ignoring meaningless parts of a URL</a>
  </figcaption>  
  <code class=anatomy>
    <span class=pink style='--depth: 2'>https://example.com/<span>exampleSpec<aside>name</aside></span><aside>
      identity
    </aside></span>/<span style='--depth: 2' class=green>v1.0<aside>version</aside></span><span class=grey>?key=val&k2=v2#fragment<aside>ignored</aside></span>
  </code>
</figure>

### Why is versioning in the URL, not a directive argument?

The version is in the URL because when a human reader visits the URL, we would like them to be taken to the documentation for the *version of the specification in use by this document*. Many text editors will turn URLs into hyperlinks, and it's highly desirable that clicking the link takes the user to the correct version of the docs. Putting the version information in a separate argument to the `@core` directive would require this.

## Prefixing

Core feature specifications **must** prefix any schema elements they introduce. The prefix:
1. **must** be a string of characters valid within GraphQL typenames, with the exception of two underscores (`"__"`)
2. **must** match the default name of the feature, as derived from the feature's specification URL.

With the exception of their root directive, specs **should** define any new schema elements with names that start with `$name__`. The root directive can simply be named with the name of the spec.

```graphql
#::[Using the `@core` directive with a spec's default name]
schema @core(feature: "https://spec.example.com/example/v1.0") {
  query: Query
}

type User {
  name: String @example(data: ITEM)
}

# An enum used to provide structured data to the example spec.
# It is prefixed with the name of the spec.
enum example__Data {
  ITEM
}

directive @example(data: example__Data) on FIELD
```

The language of the spec **should** specify the default prefix and **should** identify locations where the prefix is used. The prefix **should not** be elided within documentation; definitions of schema elements provided within the spec **must** include the default prefix.

### Elements which should be prefixed
Specs **should** attach their prefix to:
- the names of any object types, interfaces, unions, enums, or input object types defined in the spec
- the names of any fields the spec introduces on *foreign types* defined in a different spec
- the names of any arguments the spec introduces on *foreign directives and fields* defined in a different spec
- the names of any directives introduced in the spec
  - specs may introduce one **root directive**, which carries *only* the prefix and no underscore.

<view-of src=prefixing.graphql
  title='Prefixing examples'
></view-of>

## Versioning

Specs are versioned with a **subset** of a [Semantic Version Number](https://semver.org/spec/v2.0.0.html) containing only the `major` and `minor` parts. Thus, specifications **should** provide a version of the form `‹major›.‹minor›`, where both integers >= 0.

```
#::[Examples of valid versions]
2.2
1.0
1.1
0.1
```

As specified by semver, spec authors **should** increment the:
> - MAJOR version when you make incompatible API changes,
> - MINOR version when you add functionality in a backwards compatible manner

Patch and pre-release qualifiers are judged to be not particularly meaningful in the context of specifications, which are (by definition) interfaces rather than implementations. The `‹patch›` component of version denotes a bug fix which is backwards compatible—that is, a change to the implementation which does not affect the interface. `‹patch›`-level changes in the version of a spec denote wording clarifications which do not require implementation changes. As such, it is not important to track them for the purposes of version resolution.

As with [semver](https://semver.org/spec/v2.0.0.html), the `0.x` version series is special: there is no expectation of compatibility between versions `0.x` and `0.y`. For example, a processor must not activate implementation `0.4` to satisfy a requested version of `0.2`.

### Ordering
Versions can be ordered with the following pseudocode:

```typescript
compareVersions(a: Version, b: Version) -> LESS_THAN | EQUAL | GREATER_THAN {
  if a.major < b.major {
    return LESS_THAN
  }
  if a.major == b.major {
    if a.minor == b.minor { return EQUAL }
    if a.minor > b.minor { return GREATER_THAN }
    return LESS_THAN
  }
  if a.major > b.major {
    return GREATER_THAN
  }
}
```

Note that this ordering does *not* guarantee that if A > B then A can satisfy a version requirement of B. For example, `2.0 > 1.9`, but `2.0` cannot [satisfy](#satisfying-version-requirements) the requirements of a document which references version `1.9`, since the major version update introduced possibly-breaking changes.

### Satisfaction

Given a version `requested` by a document and an `available` version of an implementation, the following pseudocode will determine if the `available` version can satisfy the `requested` version:

```typescript
canSatisfy(requested: Version, available: Version) =
  requested.major == available.major &&
  (requested.major > 0 && (requested.minor <= available.minor)
    || (requested.minor == available.minor))
```

### Referencing versions and activating implementations

Schema documents **must** reference a feature version which supports all the schema elements and behaviors required by the document. As a practical matter, authors should generally prefer to reference the [lowest](#ordering) versions which can [satisfy](#satisfaction) their requirements, as this imposes the fewest constraints on processors and is thus more likely to be supported. Authors **may** choose a higher version which they believe has sufficient support.

If a processor chooses to activate support for a feature, the processor **must** activate an implementation which can [satisfy](#satisfaction) the version required by the document.

### Backus-Naur Form for versions and version tags

```plaintext
#::[BNF grammar for SemVer specifiers]
‹version tag› ::= "v" ‹version›

‹version› ::= ‹major› "." ‹minor›

‹major› ::= ‹numeric identifier›
‹minor› ::= ‹numeric identifier›
‹numeric identifier› ::= "0"
                       | ‹positive digit›
                       | ‹positive digit› ‹digits›
‹digits› ::= ‹digit›
           | ‹digit› ‹digits›

‹digit› ::= "0"
          | ‹positive digit›
‹positive digit› ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
```

## Extensibility

Any directives, scalars, enums, input objects, and other schema elements defined by specs **may** be **extensible**. This means that their definitions within a core schema document do not have to exactly match definitions provided by specs. Instead, definitions should match all usages within the document.

Standard extensibility rules:
- **Directives** may be defined as taking additional arguments, provided those arguments are [prefixed](#prefixing) with the name of a document feature followed by two underscores ("`__`"). These arguments are interpreted as metadata-on-metadata, and are routed to the declaring spec for interpretation
- **Enums** defined in features may include values of any name. For extensible enums, the space of **unprefixed** names belongs to the document. The space of **prefixed** names belongs to the spec with that prefix, and may be used to pass data between specs.
- **Input Objects** may be defined with additional fields, provided those fields are [prefixed](#prefixing) with the name of a feature followed by two underscores.

## Processing Schemas

```mermaid
#::[Example processing pipeline]
graph LR
  schema(["📄  Input Schema"]):::file-->proc("🤖 &nbsp;Processor")
  proc-->output(["📄  Output Schema"]):::file
  classDef file fill:none,color:#eee;
  style proc fill:none,stroke:fuchsia,color:fuchsia;
```

A common use case is that of a processor which consumes a valid input schema and generates an output schema.

The general guidance for processor behavior is: don't react to what you don't understand.

Specifically, processors:
  - **should** pass through `@core` directives which reference unknown feature URLs
  - **should** pass through prefixed directives, types, and other schema elements  

An exception to this is processors which prepare the schema for final public consumption. Such processors **may** choose to eliminate all unknown directives and prefixed types in order to hide schema implementation details within the published schema. This will impair the operation of tooling which relies on these directives—such tools will not be able to run on the output schema, so the benefits and costs of this kind of information hiding should be weighed carefully on a case-by-case basis.

## Validations

### Prefix Uniqueness

**Formal Specification**
- For each `@core` directive `d` on the SchemaDefinition within the Document,
  - Let `prefix` be the spec's [prefix](#prefixing) as specified by the directive's `as:` argument or, if the argument is not present, the default prefix specified in the [spec url](#feature-urls).   
  - For each other `@core` directive `e` where `e ≠ d` on the SchemaDefinition within the Document,
    - Let `otherPrefix` be the spec's [prefix](#prefixing) as specified by the directive's `as:` argument or, if the argument is not present, the prefix specified in the [spec url](#feature-urls).
    - `otherPrefix` must not equal `prefix`

**Explanatory Text**

Prefixes, whether implicit or explicit, must be unique within a document. Valid:

<view-of src=prefixing.graphql#schema[0]
  title="Example of unique prefixes"
></view-of>

It is also valid to reference multiple versions of the same spec under different prefixes:

<view-of src=prefix-uniqueness.graphql#schema[0]
  title="Explicit prefixes allow multiple versions of the same spec to coexist within a Document"
></view-of>

Without the explicit `as:`, the above would be invalid:

<view-of src=prefix-uniqueness.graphql#schema[1]
  title="Counter-example of non-unique prefixes with multiple versions of the same spec"
  class=counter-example
></view-of>

Different specs with the same prefix are also invalid:

<view-of src=prefix-uniqueness.graphql#schema[2]
  title="Counter-example of non-unique prefixes"
  class=counter-example
></view-of>

</main>
</div>
