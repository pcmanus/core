<!doctype html>
<script src=/boot.js></script>
<title>Core Schemas</title>

<div id=view>
<main markdown>
<header>
  <h1>Core Schemas</h1>
  <h2>extensible GraphQL schemas for powering data cores</h2>

  <table class=spec-md>
    <tr>
      <td>status</td>
      <td id=spec-md-status>Draft</dd>
    </tr>
    <tr>
      <td>version</td>
      <td id=spec-md-version>0.1</dd>
    </tr>
    <tr>
      <td>authors</td>
      <td id=spec-md-authors>
        <ul class=spec-authors-list>
          <li><a rel=author href=mailto:ashi@apollographql.com>Ashi Krishnan</a>
        </ul>
      </td>
    </tr>
  </table>
</header>

## Problem

[GraphQL](https://spec.graphql.org/) provides *directives* to attach user-defined metadata to GraphQL document. Directives are highly flexible, and can be used to suggest behavior, define features of a graph which are not otherwise evident in the schema.

Alas, **GraphQL does not provide a mechanism to identify or version directives**. Given a particular directive—e.g. `@external`—processors are expected to know how to interpret the directive based only on its name, definition within the document, and additional configuration from outside the document. This is unfortunate, because it means that any piece of software which serves a schema needs two pieces of configuration: the schema, and metadata about how to interpret the schema. These two pieces of configuration are generally in separate formats, and must be maintained in sync throughout the schema processing pipeline. GraphQL schemas are generally intended to be self-describing, and this lack of clarity effectively breaks that contract: given a schema, programs do not necessarily know how to interpret it, and certainly not how to serve it.

Core schemas rectify this problem by providing a clear and concise way for schema documents to specify the intended meaning of the directives (and other supporting schema elements) which they contain. The intention behind core schemas is to provide a *single document* which provides all the necessary configuration of a *data core*—some program which serves the schema to GraphQL clients, primarily following directives in order to determine how to resolve queries made against that schema.

To that end, we introduce a new directive, the `@core` directive, which allows documents to reference versioned, namespaced *specifications* which describe the intended behavior of those directives and any supporting schema elements (primarily types in the input schema which can serve as arguments to the directive).

## Actors

```mermaid
#::[Actors who may be interested in the core schemas]
graph TB
  author("👩🏽‍💻 🤖  &nbsp;Author")-->schema(["☉ Core Schema"])
  schema-->proc1("🤖 &nbsp;Processor")
  proc1-->output1(["☉ Core Schema[0]"])
  output1-->proc2("🤖 &nbsp;Processor")
  proc2-->output2(["☉ Core Schema[1]"])
  output2-->etc("...")
  etc-->final(["☉ Core Schema [final]"])
  final-->core("🤖 Data Core")
  schema-->reader("👩🏽‍💻  Reader")
  output1-->reader
  output2-->reader
  final-->reader
```

- **Authors (either human or machine)** write an initial core schema as specified in this document, including versioned `@core` requests for all directives they use
- **Machine processors** can process core schemas and output new core schemas. The versioning of directives and associated schema elements provided by the `@core` allows processors to operate on directives they understand and pass through directives they do not.
- **Human readers** can examine the core schema at various stages of processing. At any stage, they can examine the `@core` directives and follow URLs to the specification, receiving an explanation of the requirements of the specification and what new directives, types, and other schema objects are available within the document.

## `@core` within a document

The `@core` directive is applied to `schema` declarations to declare that the schema uses a particular spec. For example,

```graphql
#::[Using the `@core` directive]
schema
  @core(using: "https://lib.apollo.dev/core/v0.1")
  @core(using: "https://specs.example.com/example/v1.0") {
  query: Query
}

type SomeType {
  field: Int @example
}
```

This basic example demonstrates the basic features of core schemas and the `@core` directive:
1. Directives and associated schema elements can be linked to the schema via the `@core` directive
2. The first `@core` directive **must** reference the core spec itself.

## The `@core` directive

```graphql
#::[Definition of the `@core` directive]
directive @core(using: String!, prefix: String)
  repeatable on SCHEMA
```

Documents **must** include a definition for the `@core` directive. The provided definition does not have to match the above definition exactly. Instead, it must be *compatible*. A conforming definition may:
- **Omit optional arguments** if they are never used in the document.
- **Introduce new directive locations**, the behavior of which is unspecified here.
- **Introduce new arguments.** New arguments **must** be prefixed, e.g. `example__feature: Bool`. The prefix **must** be the prefix of a spec referenced with this or another `@core` directive within the document.

### `spec`

A URL identifying the spec. When viewed, the URL **should** provide the content of the appropriate version of the specification in some human-readable form. In short, a human reader should be able to click the link and go to the docs for the version in use. It is not required that the *content* be machine-readable in any particular way.

<figure>
  <figcaption>
    <a name=anatomy-of-a-spec-url href=#anatomy-of-a-spec-url class=a-header>Basic anatomy of a spec URL</a>
  </figcaption>  
  <code class=anatomy>
    <span class=pink style='--depth: 2'>http://spec.example.com/a/b/c/<span>exampleSpec<aside>prefix</aside></span><aside>
      identity
    </aside></span>/<span style='--depth: 2' class=green>v1<aside>version</aside></span>
  </code>
</figure>

Spec URLs contain information about the spec's [prefix](#prefixing) and [version](#versioning), and should be generated and processed in accordance with the [requirements on the structure of spec URLs](#spec-urls).

### `prefix`

Change the [prefix](#prefixing) for schema elements from this specification.

When a `prefix` is provided, processors **must** configure the resulting implementation to replace the default prefix on the names of all [prefixed schema elements](#elements-which-should-be-prefixed) with the specified prefix.

```graphql
#::[Using the `@core` directive with a custom prefix]
schema @core(using: "https://spec.example.com/example/v1", prefix: "eg") {
  query: Query
}

type User {
  # Specifying `prefix: "eg"` transforms @example_someDirective from
  # the example spec into @eg_someDirective
  name: String @eg__someDirective
}

# Prefix transformation must also be applied to definitions pulled in from
# specifications.
directive @eg__someDirective on FIELD
```

This argument has no effect on specs which do not introduce prefixed schema elements.

## Requiring `@core` within a spec

Specifications **may** include the following language to instruct schema authors to use `@core` to indicate documents which are intended to conform to the specification:

> SPEC_NAME schema documents **must**/**should**/**may** have a `schema` declaration with a [`@core` directive](/core/drafts/pre-0)
> and the specification URL `SPEC_URL`:
>
> ```graphql
> schema @core(using: SPEC_URL) {
>   query: Query
> }
> ```

`SPEC_NAME` and `SPEC_URL` should be replaced with the names and URLs for the specification. For example:

> Example Spec schema documents **must** have a `schema` declaration with a [`@core` directive](/core/drafts/pre-0)
> and the specification URL `https://specs.example.com/example/v1`:
>
> ```graphql
> schema @core(using: "https://specs.example.com/example/v1") {
>   query: Query
> }
> ```

## Spec URLs

Spec URLs serve two main purposes:
  - Directing human readers to documentation about the specification(s) in use.
  - Providing tools with information about the specs in use, along with enough information to select and invoke an implementation
  
Spec URLs **should** be [RFC 3986 URLs](https://tools.ietf.org/html/rfc3986). When viewed, the URL **should** provide the content of the selected version of the specification in some human-readable form; a human reader should be able to click the link and go to the correct version of the docs.

Although they are not prohibited from doing so, it's assumed that processors will not load the content of spec URLs. Published specifications are not required to be machine-readable, and [this spec](.) places no requirements on the structure or syntax of the content to be found there.

There are, however, requirements on the structure of the URL itself:

<figure>
  <figcaption>
    <a name=basic-anatomy-of-a-spec-url href=#basic-anatomy-of-a-spec-url class=a-header>Basic anatomy of a spec URL</a>
  </figcaption>  
  <code class=anatomy>
    <span class=pink style='--depth: 2'>https://spec.example.com/a/b/c/<span>exampleSpec<aside>prefix</aside></span><aside>
      identity
    </aside></span>/<span style='--depth: 2' class=green>v1.0<aside>version</aside></span>
  </code>
</figure>

The final two segments of the URL's [path](https://tools.ietf.org/html/rfc3986#section-3.3) **should** contain the spec's [default prefix](#prefix) and a [version tag](#versioning). The content of the URL up to and including the prefix—but excluding the version tag and trailing `/`—is the spec's *identity*. For the above example,
<dl>
  <dt markdown>`identity: "https://spec.example.com/a/b/c/exampleSpec"`</dt>
  <dd>A global identifier for the spec. Processors can treat this as an opaque string identifying the spec (but not the version of the spec) for purposes of selecting an appropriate implementation.</dd>
  <dt markdown>`prefix: "exampleSpec"`</dt>
  <dd markdown>The spec's default prefix for purposes of [prefixing](#prefixing) schema elements it defines or extends. URLs for specs which do not employ prefixing will still be interpreted as specifying a default prefix; the default prefix will simply have no effect on implementation behavior.</dd>
  <dt markdown>`version: "v1.0"`</dt>
  <dd markdown>The tag for the [version](#versioning) of the spec used to author the document. Processors **must** select an implementation of the spec which can [satisfy](#satisfaction) the specified version.</dd>
</dl>

The version tag **must** satisfy the [BNF grammar for `‹version tag›`](#backus-naur-form-for-versions-and-version-tags).

### Ignore meaningless URL components

When extracting the URL's `prefix` and `version`, processors **must** ignore any url components which are not assigned a meaning. This spec assigns meaning to the final two components of the [path](https://tools.ietf.org/html/rfc3986#section-3.3). Other URL components—particularly query strings and fragments, if present—**must** be ignored for the purposes of extracting the `prefix` and `version`.

<figure>
  <figcaption>
    <a name=spec-url-ignore-meaningless href=#spec-url-ignore-meaningless class=a-header>Ignoring meaningless parts of a URL</a>
  </figcaption>  
  <code class=anatomy>
    <span class=pink style='--depth: 2'>https://example.com/<span>exampleSpec<aside>prefix</aside></span><aside>
      identity
    </aside></span>/<span style='--depth: 2' class=green>v1.0<aside>version</aside></span><span class=grey>?key=val&k2=v2#fragment<aside>ignored</aside></span>
  </code>
</figure>

### Why is versioning in the URL, not a directive argument?

The version is in the URL because when a human reader visits the URL, we would like them to be taken to the documentation for the *version of the specification in use by this document*. Many text editors will turn URLs into hyperlinks, and it's highly desirable that clicking the link takes the user to the correct version of the docs. Putting the version information in a separate argument to the `@core` directive would require this.

## Prefixing
Specifications meant to be referenced via `@core` **should** prefix any schema elements they introduce. The prefix **must** be a string of characters valid within GraphQL typenames, with the exception of `"_"`.

Specs **should** define any new schema elements with names that start with `prefix_`.

```graphql
#::[Using the `@core` directive with a spec's default prefix]
schema @core(using: "https://spec.example.com/example/v1") {
  query: Query
}

type User {
  name: String @example_someDirective
               # prefixed directive from the example spec
}
```

The language of the spec **should** specify the default prefix and **should** identify locations where the prefix is used. The prefix **should not** be elided within documentation; definitions of schema elements provided within the spec **must** include the default prefix.

### Elements which should be prefixed
Specs **should** attach their prefix to:
- the names of any object types, interfaces, unions, enums, or input object types defined in the spec
- the names of any fields the spec introduces on *foreign types* defined in a different spec
- the names of any arguments the spec introduces on *foreign directives and fields* defined in a different spec
- the names of any directives introduced in the spec
  - specs may introduce one **root directive**, which carries *only* the prefix and no underscore.

<view-of src=prefixing.graphql
  title='Prefixing examples'
></view-of>

## Versioning

Specs are versioned with a **subset** of a [Semantic Version Number](https://semver.org/spec/v2.0.0.html) containing only the `major` and `minor` parts. Thus, specifications **should** provide a version of the form `‹major›.‹minor›`, where both integers >= 0.

```
#::[Examples of valid versions]
2.2
1.0
1.1
0.1
```

As specified by semver, spec authors **should** increment the:
> - MAJOR version when you make incompatible API changes,
> - MINOR version when you add functionality in a backwards compatible manner

Patch and pre-release qualifiers are judged to be not particularly meaningful in the context of specifications, which are (by definition) interfaces rather than implementations. The `‹patch›` component of version denotes a bug fix which is backwards compatible—that is, a change to the implementation which does not affect the interface. `‹patch›`-level changes in the version of a spec denote wording clarifications which do not require implementation changes. As such, it is not important to track them for the purposes of version resolution.

As with [semver](https://semver.org/spec/v2.0.0.html), the `0.x` version series is special: there is no expectation of compatibility between versions `0.x` and `0.y`. For example, a processor must not activate implementation `0.4` to satisfy a requested version of `0.2`.

### Ordering
Versions can be ordered with the following pseudocode:

```typescript
compareVersions(a: Version, b: Version) -> LESS_THAN | EQUAL | GREATER_THAN {
  if a.major < b.major {
    return LESS_THAN
  }
  if a.major == b.major {
    if a.minor == b.minor { return EQUAL }
    if a.minor > b.minor { return GREATER_THAN }
    return LESS_THAN
  }
  if a.major > b.major {
    return GREATER_THAN
  }
}
```

Note that this ordering does *not* guarantee that if A > B then A can satisfy a version requirement of B. For example, `2.0 > 1.9`, but `2.0` cannot [satisfy](#satisfying-version-requirements) the requirements of a document which references version `1.9`, since the major version update introduced possibly-breaking changes.

### Satisfaction

Given a version `requested` by a document and an `available` version of an implementation, the following pseudocode will determine if the `available` version can satisfy the `requested` version:

```typescript
canSatisfy(requested: Version, available: Version) =
  requested.major == available.major &&
  (requested.major > 0 && (requested.minor <= available.minor)
    || (requested.minor == available.minor))
```

### Referencing versions and activating implementations

Schema documents **must** reference a spec version which supports all the schema elements and behaviors required by the document. As a practical matter, authors should prefer to reference the [lowest](#ordering) versions which can [satisfy](#satisfaction) their requirements, as this imposes the fewest constraints on processors and is thus more likely to be supported.

For every spec they support, processors **must** activate an implementation which can [satisfy](#satisfaction) the version required by the document.

### Backus-Naur Form for versions and version tags

```plaintext
#::[BNF grammar for SemVer specifiers]
‹version tag› ::= "v" ‹version›

‹version› ::= ‹major›
            | ‹major› "." ‹minor›

‹major› ::= ‹numeric identifier›
‹minor› ::= ‹numeric identifier›
‹numeric identifier› ::= "0"
                       | ‹positive digit›
                       | ‹positive digit› ‹digits›
‹digits› ::= ‹digit›
           | ‹digit› ‹digits›

‹digit› ::= "0"
          | ‹positive digit›
‹positive digit› ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
```

## Processing Schemas

```mermaid
#::[Example processing pipeline]
graph LR
  schema(["📄  Input Schema"]):::file-->proc("🤖 &nbsp;Processor")
  proc-->output(["📄  Output Schema"]):::file
  classDef file fill:none,color:#eee;
  style proc fill:none,stroke:fuchsia,color:fuchsia;
```

A common use case is that of a processor which consumes a valid input schema and generates an output schema.

The general guidance for processor behavior is: don't react to what you don't understand.

Specifically, processors:
  - **should** pass through `@core` directives which reference unknown spec URLs
  - **should** pass through prefixed directives, types, and other schema elements  

An exception to this is processors which prepare the schema for final public consumption. Such processors **may** choose to eliminate all unknown directives and prefixed types in order to hide schema implementation details within the published schema. This will impair the operation of tooling which relies on these directives—such tools will not be able to run on the output schema, so the benefits and costs of this kind of information hiding should be weighed carefully on a case-by-case basis.

## Validations

### Prefix Uniqueness

**Formal Specification**
- For each `@core` directive `d` on the SchemaDefinition within the Document,
  - Let `prefix` be the spec's [prefix](#prefixing) as specified by the directive's `prefix:` argument or, if the argument is not present, the default prefix specified in the [spec url](#spec-urls).   
  - For each other `@core` directive `e` where `e ≠ d` on the SchemaDefinition within the Document,
    - Let `otherPrefix` be the spec's [prefix](#prefixing) as specified by the directive's `prefix:` argument or, if the argument is not present, the prefix specified in the [spec url](#spec-urls).
    - `otherPrefix` must not equal `prefix`

**Explanatory Text**

Prefixes, whether implicit or explicit, must be unique within a document. Valid:

<view-of src=prefixing.graphql#schema[0]
  title="Example of unique prefixes"
></view-of>

It is also valid to reference multiple versions of the same spec under different prefixes:

<view-of src=prefix-uniqueness.graphql#schema[0]
  title="Explicit prefixes allow multiple versions of the same spec to coexist within a Document"
></view-of>

Without the explicit `prefix:`, the above would be invalid:

<view-of src=prefix-uniqueness.graphql#schema[1]
  title="Counter-example of non-unique prefixes with multiple versions of the same spec"
  class=counter-example
></view-of>

Different specs with the same prefix are also invalid:

<view-of src=prefix-uniqueness.graphql#schema[2]
  title="Counter-example of non-unique prefixes"
  class=counter-example
></view-of>

</main>
</div>
